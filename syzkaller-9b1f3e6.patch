diff --git a/Makefile b/Makefile
index b2886786..ddc65fa9 100644
--- a/Makefile
+++ b/Makefile
@@ -107,7 +107,7 @@ all: host target
 
 host:
 	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) install ./syz-manager
-	$(MAKE) manager runtest repro mutate prog2c db upgrade
+	$(MAKE) manager runtest repro mutate prog2c db upgrade branch2addr logparser
 
 target:
 	GOOS=$(TARGETGOOS) GOARCH=$(TARGETGOARCH) $(GO) install ./syz-fuzzer
@@ -177,6 +177,11 @@ usbgen:
 expand:
 	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-expand github.com/google/syzkaller/tools/syz-expand
 
+branch2addr:
+	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-branch2addr github.com/google/syzkaller/tools/syz-branch2addr
+
+logparser:
+	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-logparser github.com/google/syzkaller/tools/syz-logparser
 # `extract` extracts const files from various kernel sources, and may only
 # re-generate parts of files.
 extract: bin/syz-extract
diff --git a/courier/queue.go b/courier/queue.go
new file mode 100644
index 00000000..773c97e0
--- /dev/null
+++ b/courier/queue.go
@@ -0,0 +1,80 @@
+package courier
+
+import (
+	"sync"
+
+	"github.com/google/syzkaller/pkg/rpctype"
+)
+
+const (
+	Mutating = 0
+	Commands = 1
+	S2E      = 2
+	Critical = 3
+)
+
+type S2EArgs struct {
+	Prog    []byte
+	Pointer []byte
+}
+
+var MutateArgsQueue = make([]rpctype.ProgQueue, 0)
+var CriticalPoCQueue = make([]rpctype.ProgQueue, 0)
+
+var CommandsQueue = make([]string, 0)
+var S2EArgsQueue = make([]S2EArgs, 0)
+var Mutex = &sync.Mutex{}
+
+//Append testcase to a queue waits for mutating
+func AppendMutatingQueue(p, pocProg []byte, nOfCalls int) {
+	a := rpctype.ProgQueue{
+		Prog:     p,
+		NOfCalls: nOfCalls,
+		PocProg:  pocProg,
+	}
+	MutateArgsQueue = append(MutateArgsQueue, a)
+}
+
+func AppendCriticalPoCQueue(p []byte) {
+	a := rpctype.ProgQueue{
+		Prog:     p,
+		NOfCalls: 0,
+		PocProg:  p,
+	}
+	CriticalPoCQueue = append(CriticalPoCQueue, a)
+}
+
+func AppendCommandsQueue(p []byte) {
+	CommandsQueue = append(CommandsQueue, string(p))
+}
+
+func AppendS2EQueue(p S2EArgs) {
+	S2EArgsQueue = append(S2EArgsQueue, p)
+}
+
+func RetrieveFirstArg(flag int) interface{} {
+	switch flag {
+	case Mutating:
+		if len(MutateArgsQueue) == 0 {
+			break
+		}
+		p := MutateArgsQueue[0]
+		MutateArgsQueue = MutateArgsQueue[1:]
+		return p
+	case Commands:
+		if len(CommandsQueue) == 0 {
+			break
+		}
+		p := CommandsQueue[0]
+		CommandsQueue = CommandsQueue[1:]
+		return []byte(p)
+	case S2E:
+		if len(S2EArgsQueue) == 0 {
+			break
+		}
+		p := S2EArgsQueue[0]
+		S2EArgsQueue = S2EArgsQueue[1:]
+		return p
+	}
+	return nil
+}
diff --git a/courier/utilities.go b/courier/utilities.go
new file mode 100644
index 00000000..dd77605a
--- /dev/null
+++ b/courier/utilities.go
@@ -0,0 +1,68 @@
+package courier
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"os"
+	"path"
+
+	"github.com/google/syzkaller/pkg/log"
+)
+
+var AnalyzerPath string
+var ConfirmedSuccess = false
+
+func AppendTestcase(testcase, pocProg []byte, nOfCalls int) {
+	AppendMutatingQueue(testcase, pocProg, nOfCalls)
+}
+
+func RemoveComments(text []byte) []byte {
+	var res []byte
+	start := 0
+	lines := bytes.SplitAfter(text, []byte("\n"))
+	for i, line := range lines {
+		if line[0] != '#' {
+			start = i
+			break
+		}
+	}
+	for i := start; i < len(lines); i++ {
+		res = append(res, lines[i]...)
+	}
+	return res
+}
+
+func checkDuplication(hash string, f *os.File) bool {
+	line := make([]byte, 8)
+	for {
+		n, err := f.Read(line)
+		if n == 0 && err == io.EOF {
+			break
+		}
+		if err != nil {
+			fmt.Printf("Fail to read: %v\n", err)
+			return true
+		}
+		if string(line[:len(line)-1]) == hash {
+			return true
+		}
+	}
+	return false
+}
+
+func SaveToFile(filename string) {
+	hash := path.Base(AnalyzerPath)
+	work := path.Dir(path.Dir(AnalyzerPath))
+	success := path.Join(work, filename)
+	f, err := os.OpenFile(success, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0600)
+	if err != nil {
+		log.Logf(0, "Fail to open %s: %v", success, err)
+		return
+	}
+	defer f.Close()
+	if !checkDuplication(hash, f) {
+		log.Logf(0, "Write %s to %s", filename, success)
+		f.WriteString(hash + "\n")
+	}
+}
diff --git a/pkg/build/netbsd.go b/pkg/build/netbsd.go
index 68836f3a..b5e471c2 100644
--- a/pkg/build/netbsd.go
+++ b/pkg/build/netbsd.go
@@ -136,7 +136,7 @@ func (ctx netbsd) copyKernelToDisk(targetArch, vmType, outputDir, kernel string)
 		return fmt.Errorf("error syncing the instance %v", err)
 	}
 	// Make sure that the command has executed properly.
-	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitNormal)
+	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitNormal, time.Now(), -1)
 	if rep != nil {
 		return fmt.Errorf("error executing sync: %v", rep.Title)
 	}
diff --git a/pkg/compiler/check.go b/pkg/compiler/check.go
index 7f12d74a..31387554 100644
--- a/pkg/compiler/check.go
+++ b/pkg/compiler/check.go
@@ -546,8 +546,7 @@ func (comp *compiler) collectUsedType(structs, flags, strflags map[string]bool,
 
 func (comp *compiler) checkUnused() {
 	for _, n := range comp.collectUnused() {
-		pos, typ, name := n.Info()
-		comp.error(pos, fmt.Sprintf("unused %v %v", typ, name))
+		n.Info()
 	}
 }
 
diff --git a/pkg/instance/instance.go b/pkg/instance/instance.go
index 5adc9dc6..b95f196f 100644
--- a/pkg/instance/instance.go
+++ b/pkg/instance/instance.go
@@ -322,7 +322,7 @@ func (inst *inst) testInstance() error {
 	if err != nil {
 		return fmt.Errorf("failed to run binary in VM: %v", err)
 	}
-	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter, vm.ExitNormal)
+	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter, vm.ExitNormal, time.Now(), -1)
 	if rep != nil {
 		if err := inst.reporter.Symbolize(rep); err != nil {
 			// TODO(dvyukov): send such errors to dashboard.
@@ -410,7 +410,7 @@ func (inst *inst) testProgram(command string, testTime time.Duration) error {
 		return fmt.Errorf("failed to run binary in VM: %v", err)
 	}
 	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter,
-		vm.ExitTimeout|vm.ExitNormal|vm.ExitError)
+		vm.ExitTimeout|vm.ExitNormal|vm.ExitError, time.Now(), -1)
 	if rep == nil {
 		return nil
 	}
@@ -421,7 +421,7 @@ func (inst *inst) testProgram(command string, testTime time.Duration) error {
 }
 
 func FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs, verbosity int,
-	cover, debug, test, runtest bool) string {
+	cover, debug, test, runtest, poc bool) string {
 	osArg := ""
 	if targets.Get(OS, arch).HostFuzzer {
 		// Only these OSes need the flag, because the rest assume host OS.
@@ -438,13 +438,13 @@ func FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs,
 		verbosityArg = fmt.Sprintf(" -vv=%v", verbosity)
 	}
 	return fmt.Sprintf("%v -executor=%v -name=%v -arch=%v%v -manager=%v -sandbox=%v"+
-		" -procs=%v -cover=%v -debug=%v -test=%v%v%v",
+		" -procs=%v -cover=%v -debug=%v -test=%v%v%v -poc=%v",
 		fuzzer, executor, name, arch, osArg, fwdAddr, sandbox,
-		procs, cover, debug, test, runtestArg, verbosityArg)
+		procs, cover, debug, test, runtestArg, verbosityArg, poc)
 }
 
 func OldFuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs int, cover, test bool) string {
-	return FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox, procs, 0, cover, false, test, false)
+	return FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox, procs, 0, cover, false, test, false, false)
 }
 
 func ExecprogCmd(execprog, executor, OS, arch, sandbox string, repeat, threaded, collide bool,
diff --git a/pkg/mgrconfig/config.go b/pkg/mgrconfig/config.go
index 69df2a80..18298663 100644
--- a/pkg/mgrconfig/config.go
+++ b/pkg/mgrconfig/config.go
@@ -114,4 +114,8 @@ type Config struct {
 	SyzFuzzerBin   string `json:"-"`
 	SyzExecprogBin string `json:"-"`
 	SyzExecutorBin string `json:"-"`
+	Testcase       string `json:"testcase"`
+	AnalyzerDir    string `json:"analyzer_dir"`
+	TimeLimit      string `json:"time_limit"`
+	StoreRead      bool   `json:"store_read"`
 }
diff --git a/pkg/mgrconfig/load.go b/pkg/mgrconfig/load.go
index 4e413636..857dd80d 100644
--- a/pkg/mgrconfig/load.go
+++ b/pkg/mgrconfig/load.go
@@ -11,6 +11,7 @@ import (
 	"strings"
 
 	"github.com/google/syzkaller/pkg/config"
+	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/osutil"
 	"github.com/google/syzkaller/prog"
 	_ "github.com/google/syzkaller/sys" // most mgrconfig users want targets too
@@ -208,7 +209,7 @@ func ParseEnabledSyscalls(target *prog.Target, enabled, disabled []string) ([]in
 				}
 			}
 			if n == 0 {
-				return nil, fmt.Errorf("unknown enabled syscall: %v", c)
+				log.Logf(0, "unknown enabled syscall: %v", c)
 			}
 		}
 	} else {
@@ -225,11 +226,11 @@ func ParseEnabledSyscalls(target *prog.Target, enabled, disabled []string) ([]in
 			}
 		}
 		if n == 0 {
-			return nil, fmt.Errorf("unknown disabled syscall: %v", c)
+			log.Logf(0, "unknown disabled syscall: %v", c)
 		}
 	}
 	if len(syscalls) == 0 {
-		return nil, fmt.Errorf("all syscalls are disabled by disable_syscalls in config")
+		log.Logf(0, "all syscalls are disabled by disable_syscalls in config")
 	}
 	var arr []int
 	for id := range syscalls {
diff --git a/pkg/report/linux.go b/pkg/report/linux.go
index 07c061ff..32bdea36 100644
--- a/pkg/report/linux.go
+++ b/pkg/report/linux.go
@@ -129,7 +129,7 @@ func (ctx *linux) ContainsCrash(output []byte) bool {
 }
 
 func (ctx *linux) Parse(output []byte) *Report {
-	oops, startPos, context := ctx.findFirstOops(output)
+	oops, startPos, context := ctx.findCriticalOops(output)
 	if oops == nil {
 		return nil
 	}
@@ -185,6 +185,75 @@ func (ctx *linux) findFirstOops(output []byte) (oops *oops, startPos int, contex
 	return
 }
 
+func (ctx *linux) findCriticalOops(output []byte) (oops *oops, startPos int, context string) {
+	index := ChooseCriticalCrash(output)
+	for pos, next := 0, 0; pos < len(output); pos = next + 1 {
+		next = bytes.IndexByte(output[pos:], '\n')
+		if next != -1 {
+			next += pos
+		} else {
+			next = len(output)
+		}
+		line := output[pos:next]
+		for _, oops1 := range linuxOopses {
+			if matchOops(line, oops1, ctx.ignores) {
+				oops = oops1
+				startPos = pos
+				context = ctx.extractContext(line)
+				if len(index) == 0 {
+					return
+				}
+				break
+			}
+		}
+		if len(index) > 0 {
+			if pos <= index[0][0] && next >= index[0][1] {
+				return
+			}
+		}
+	}
+	return
+}
+
+func ChooseCriticalCrash(output []byte) [][]int {
+	var index [][]int
+	var crashRegx []*regexp.Regexp
+	//kasanRegx := regexp.MustCompile(`BUG: KASAN: ([a-z\\-]+) in ([a-zA-Z0-9_]+).*`)
+	//oobReadRegx := regexp.MustCompile(`\?!\?MAGIC\?!\?read->(\w*) size->(\d*)`)
+	if ReadIsCritical {
+		crashRegx = append(crashRegx, regexp.MustCompile(`Read of size (\d+) at addr (\w*)`))
+	}
+	crashRegx = append(crashRegx, regexp.MustCompile(`Write of size (\d+) at addr (\w*)`))
+	crashRegx = append(crashRegx, regexp.MustCompile(`BUG: KASAN: double-free or invalid-free in`))
+	crashRegx = append(crashRegx, regexp.MustCompile(`invalid-free in`))
+	for _, each := range crashRegx {
+		index = each.FindAllIndex(output, -1)
+		if len(index) > 0 {
+			break
+		}
+	}
+	return index
+}
+
+func (ctx *linux) takeAfterContext(line []byte) []byte {
+	prefix := ctx.extractContext(line)
+	index := strings.Index(string(line), prefix)
+	new := make([]byte, len(line)-(index+len(prefix))+1)
+	copy(new, line[index+len(prefix):])
+	return new
+}
+
+func (ctx *linux) getNextLine(start int, output []byte) []byte {
+	next := bytes.IndexByte(output[start:], '\n')
+	if next != -1 {
+		next += start
+	} else {
+		next = len(output)
+	}
+	line := output[start:next]
+	return line
+}
+
 // Yes, it is complex, but all state and logic are tightly coupled. It's unclear how to simplify it.
 // nolint: gocyclo
 func (ctx *linux) findReport(output []byte, oops *oops, startPos int, context string) (
diff --git a/pkg/report/report.go b/pkg/report/report.go
index c9832c9a..461429f9 100644
--- a/pkg/report/report.go
+++ b/pkg/report/report.go
@@ -83,6 +83,8 @@ func (t Type) String() string {
 	}
 }
 
+var ReadIsCritical bool
+
 // NewReporter creates reporter for the specified OS/Type.
 func NewReporter(cfg *mgrconfig.Config) (Reporter, error) {
 	typ := cfg.TargetOS
diff --git a/pkg/repro/repro.go b/pkg/repro/repro.go
index 6de117df..17473a45 100644
--- a/pkg/repro/repro.go
+++ b/pkg/repro/repro.go
@@ -29,7 +29,8 @@ type Result struct {
 	CRepro   bool
 	// Information about the final (non-symbolized) crash that we reproduced.
 	// Can be different from what we started reproducing.
-	Report *report.Report
+	Report  *report.Report
+	Command string
 }
 
 type Stats struct {
@@ -193,7 +194,7 @@ func Run(crashLog []byte, cfg *mgrconfig.Config, reporter report.Reporter, vmPoo
 			if res.CRepro {
 				_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)
 			} else {
-				_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)
+				_, _, err = ctx.testProg(res.Prog, res.Duration, res.Opts)
 			}
 			if err != nil {
 				return nil, nil, err
@@ -329,7 +330,7 @@ func (ctx *context) extractProgSingle(entries []*prog.LogEntry, duration time.Du
 		if opts.FaultCall < 0 || opts.FaultCall >= len(ent.P.Calls) {
 			opts.FaultCall = len(ent.P.Calls) - 1
 		}
-		crashed, err := ctx.testProg(ent.P, duration, opts)
+		crashed, command, err := ctx.testProg(ent.P, duration, opts)
 		if err != nil {
 			return nil, err
 		}
@@ -338,6 +339,7 @@ func (ctx *context) extractProgSingle(entries []*prog.LogEntry, duration time.Du
 				Prog:     ent.P,
 				Duration: duration * 3 / 2,
 				Opts:     opts,
+				Command:  command,
 			}
 			ctx.reproLog(3, "single: successfully extracted reproducer")
 			return res, nil
@@ -361,7 +363,8 @@ func (ctx *context) extractProgBisect(entries []*prog.LogEntry, baseDuration tim
 
 	// Bisect the log to find multiple guilty programs.
 	entries, err := ctx.bisectProgs(entries, func(progs []*prog.LogEntry) (bool, error) {
-		return ctx.testProgs(progs, duration(len(progs)), opts)
+		crashed, _, err := ctx.testProgs(progs, duration(len(progs)), opts)
+		return crashed, err
 	})
 	if err != nil {
 		return nil, err
@@ -386,7 +389,7 @@ func (ctx *context) extractProgBisect(entries []*prog.LogEntry, baseDuration tim
 	dur := duration(len(entries)) * 3 / 2
 
 	// Execute the program without fault injection.
-	crashed, err := ctx.testProg(prog, dur, opts)
+	crashed, command, err := ctx.testProg(prog, dur, opts)
 	if err != nil {
 		return nil, err
 	}
@@ -395,6 +398,7 @@ func (ctx *context) extractProgBisect(entries []*prog.LogEntry, baseDuration tim
 			Prog:     prog,
 			Duration: dur,
 			Opts:     opts,
+			Command:  command,
 		}
 		ctx.reproLog(3, "bisect: concatenation succeeded")
 		return res, nil
@@ -409,7 +413,7 @@ func (ctx *context) extractProgBisect(entries []*prog.LogEntry, baseDuration tim
 			if entry.FaultCall < 0 || entry.FaultCall >= len(entry.P.Calls) {
 				opts.FaultCall = calls + len(entry.P.Calls) - 1
 			}
-			crashed, err := ctx.testProg(prog, dur, opts)
+			crashed, command, err := ctx.testProg(prog, dur, opts)
 			if err != nil {
 				return nil, err
 			}
@@ -418,6 +422,7 @@ func (ctx *context) extractProgBisect(entries []*prog.LogEntry, baseDuration tim
 					Prog:     prog,
 					Duration: dur,
 					Opts:     opts,
+					Command:  command,
 				}
 				ctx.reproLog(3, "bisect: concatenation succeeded with fault injection")
 				return res, nil
@@ -444,7 +449,7 @@ func (ctx *context) minimizeProg(res *Result) (*Result, error) {
 	}
 	res.Prog, res.Opts.FaultCall = prog.Minimize(res.Prog, call, true,
 		func(p1 *prog.Prog, callIndex int) bool {
-			crashed, err := ctx.testProg(p1, res.Duration, res.Opts)
+			crashed, _, err := ctx.testProg(p1, res.Duration, res.Opts)
 			if err != nil {
 				ctx.reproLog(0, "minimization failed with %v", err)
 				return false
@@ -468,7 +473,7 @@ func (ctx *context) simplifyProg(res *Result) (*Result, error) {
 		if !simplify(&opts) {
 			continue
 		}
-		crashed, err := ctx.testProg(res.Prog, res.Duration, opts)
+		crashed, command, err := ctx.testProg(res.Prog, res.Duration, opts)
 		if err != nil {
 			return nil, err
 		}
@@ -476,6 +481,7 @@ func (ctx *context) simplifyProg(res *Result) (*Result, error) {
 			continue
 		}
 		res.Opts = opts
+		res.Command = command
 		// Simplification successful, try extracting C repro.
 		res, err = ctx.extractC(res)
 		if err != nil {
@@ -528,7 +534,7 @@ func (ctx *context) simplifyC(res *Result) (*Result, error) {
 	return res, nil
 }
 
-func (ctx *context) testProg(p *prog.Prog, duration time.Duration, opts csource.Options) (crashed bool, err error) {
+func (ctx *context) testProg(p *prog.Prog, duration time.Duration, opts csource.Options) (crashed bool, command string, err error) {
 	entry := prog.LogEntry{P: p}
 	if opts.Fault {
 		entry.Fault = true
@@ -539,25 +545,25 @@ func (ctx *context) testProg(p *prog.Prog, duration time.Duration, opts csource.
 }
 
 func (ctx *context) testProgs(entries []*prog.LogEntry, duration time.Duration, opts csource.Options) (
-	crashed bool, err error) {
+	crashed bool, command string, err error) {
 	inst := <-ctx.instances
 	if inst == nil {
-		return false, fmt.Errorf("all VMs failed to boot")
+		return false, "", fmt.Errorf("all VMs failed to boot")
 	}
 	defer ctx.returnInstance(inst)
 	if len(entries) == 0 {
-		return false, fmt.Errorf("no programs to execute")
+		return false, "", fmt.Errorf("no programs to execute")
 	}
 
 	pstr := encodeEntries(entries)
 	progFile, err := osutil.WriteTempFile(pstr)
 	if err != nil {
-		return false, err
+		return false, "", err
 	}
 	defer os.Remove(progFile)
 	vmProgFile, err := inst.Copy(progFile)
 	if err != nil {
-		return false, fmt.Errorf("failed to copy to VM: %v", err)
+		return false, "", fmt.Errorf("failed to copy to VM: %v", err)
 	}
 
 	if !opts.Fault {
@@ -575,7 +581,7 @@ func (ctx *context) testProgs(entries []*prog.LogEntry, duration time.Duration,
 		program += "]"
 	}
 
-	command := instancePkg.ExecprogCmd(inst.execprogBin, inst.executorBin,
+	command = instancePkg.ExecprogCmd(inst.execprogBin, inst.executorBin,
 		ctx.cfg.TargetOS, ctx.cfg.TargetArch, opts.Sandbox, opts.Repeat,
 		opts.Threaded, opts.Collide, opts.Procs, -1, -1, vmProgFile)
 	ctx.reproLog(2, "testing program (duration=%v, %+v): %s", duration, opts, program)
@@ -594,49 +600,49 @@ func (ctx *context) testCProg(p *prog.Prog, duration time.Duration, opts csource
 	}
 	defer os.Remove(bin)
 	ctx.reproLog(2, "testing compiled C program (duration=%v, %+v): %s", duration, opts, p)
-	crashed, err = ctx.testBin(bin, duration)
+	crashed, _, err = ctx.testBin(bin, duration)
 	if err != nil {
 		return false, err
 	}
 	return crashed, nil
 }
 
-func (ctx *context) testBin(bin string, duration time.Duration) (crashed bool, err error) {
+func (ctx *context) testBin(bin string, duration time.Duration) (crashed bool, command string, err error) {
 	inst := <-ctx.instances
 	if inst == nil {
-		return false, fmt.Errorf("all VMs failed to boot")
+		return false, bin, fmt.Errorf("all VMs failed to boot")
 	}
 	defer ctx.returnInstance(inst)
 
 	bin, err = inst.Copy(bin)
 	if err != nil {
-		return false, fmt.Errorf("failed to copy to VM: %v", err)
+		return false, bin, fmt.Errorf("failed to copy to VM: %v", err)
 	}
 	return ctx.testImpl(inst.Instance, bin, duration)
 }
 
-func (ctx *context) testImpl(inst *vm.Instance, command string, duration time.Duration) (crashed bool, err error) {
+func (ctx *context) testImpl(inst *vm.Instance, command string, duration time.Duration) (crashed bool, commands string, err error) {
 	outc, errc, err := inst.Run(duration, nil, command)
 	if err != nil {
-		return false, fmt.Errorf("failed to run command in VM: %v", err)
+		return false, command, fmt.Errorf("failed to run command in VM: %v", err)
 	}
 	rep := inst.MonitorExecution(outc, errc, ctx.reporter,
-		vm.ExitTimeout|vm.ExitNormal|vm.ExitError)
+		vm.ExitTimeout|vm.ExitNormal|vm.ExitError, time.Now(), -1)
 	if rep == nil {
 		ctx.reproLog(2, "program did not crash")
-		return false, nil
+		return false, command, nil
 	}
 	if rep.Suppressed {
 		ctx.reproLog(2, "suppressed program crash: %v", rep.Title)
-		return false, nil
+		return false, command, nil
 	}
 	if ctx.crashType == report.MemoryLeak && rep.Type != report.MemoryLeak {
 		ctx.reproLog(2, "not a leak crash: %v", rep.Title)
-		return false, nil
+		return false, command, nil
 	}
 	ctx.report = rep
 	ctx.reproLog(2, "program crashed: %v", rep.Title)
-	return true, nil
+	return true, command, nil
 }
 
 func (ctx *context) returnInstance(inst *instance) {
diff --git a/pkg/rpctype/rpctype.go b/pkg/rpctype/rpctype.go
index fcc01a99..19abe3a5 100644
--- a/pkg/rpctype/rpctype.go
+++ b/pkg/rpctype/rpctype.go
@@ -128,3 +128,27 @@ type RunTestDoneArgs struct {
 	Info   []*ipc.ProgInfo
 	Error  string
 }
+
+type ProgQueue struct {
+	Length   int
+	Prog     []byte
+	NOfCalls int
+	PocProg  []byte
+}
+
+type GetQueueLenArgs struct {
+	Flag int
+}
+
+type GetQueueLenRes struct {
+	Length int
+}
+
+type FuzzerSignal struct {
+	Signal string
+}
+
+type GetCallsFromFuzzerArgs struct {
+	EnabledCalls map[string][]int
+	Sandbox      string
+}
diff --git a/prog/encoding.go b/prog/encoding.go
index 6bded49d..f1d6a33b 100644
--- a/prog/encoding.go
+++ b/prog/encoding.go
@@ -6,10 +6,13 @@ package prog
 import (
 	"bufio"
 	"bytes"
+	"encoding/binary"
 	"encoding/hex"
 	"fmt"
 	"strconv"
 	"strings"
+
+	"github.com/google/syzkaller/pkg/log"
 )
 
 // String generates a very compact program description (mostly for debug output).
@@ -54,6 +57,256 @@ type serializer struct {
 	verbose bool
 }
 
+func (target *Target) ReadAddr(data []byte, pIndex *int) uint64 {
+	addr := target.ReadQWord(data, pIndex)
+	*pIndex -= 8
+	return addr
+}
+
+func (target *Target) ReadQWord(data []byte, pIndex *int) uint64 {
+	res := target.ReadData(data, 8, pIndex)
+	num := binary.LittleEndian.Uint64(res)
+	return num
+}
+
+func (target *Target) ReadData(data []byte, size uint64, pIndex *int) []byte {
+	//log.Logf(0, "readData pos: %d size: %d len: %d\n", *pIndex, size, len(data))
+	size_with_margin := (int(size) + 7) / 8 * 8
+	res := data[*pIndex : *pIndex+size_with_margin]
+	*pIndex += size_with_margin
+	return res
+}
+
+/*
+func (target *Target) Do(deep *int, doWhat int, num1 *uint64, num2 *uint64, arg *Arg, data interface{}) {
+	var pInfo *[]PointerInfo
+	var indexOfArgs uint64
+	var indexOfCurrentArgs uint64
+	var addr *uint64
+	var is_pointer uint64
+	var res ResData
+	var ok bool
+	//log.Logf(0, "Enter Do deep: %d doWhat: %d num1: %x num2: %x\n", *deep, doWhat, *num1, *num2)
+	if doWhat == MakePInfo {
+		pInfo, ok = data.(*[]PointerInfo)
+		if !ok {
+			return
+		}
+		indexOfArgs = *num1
+		indexOfCurrentArgs = *num2
+		(*pInfo)[*deep].IndexOfArgs = int(indexOfArgs)
+	}
+	if doWhat == UpdateProg {
+		res, ok = data.(ResData)
+		if !ok {
+			return
+		}
+		addr = num1
+		is_pointer = *num2
+	}
+	switch (*arg).(type) {
+	case *ConstArg:
+		if doWhat == UpdateProg {
+			if is_pointer != 0 {
+				if v, ok := res.ResPointer[*addr]; ok {
+					//log.Logf(0, "ConstArg addr: %x val: %#v\n", addr, v)
+					val := binary.LittleEndian.Uint64(v)
+					(*arg).(*ConstArg).Val = val
+				}
+				//log.Logf(0, "ConstArg addr: %x val: %x size: %v\n", *addr, (*arg).(*ConstArg).Val, (*arg).(*ConstArg).Size())
+				*addr += (*arg).(*ConstArg).Size()
+			} else {
+				size := target.ReadQWord(res.ResCall, deep)
+				data := target.ReadData(res.ResCall, size, deep)
+				val := binary.LittleEndian.Uint64(data)
+				(*arg).(*ConstArg).Val = val
+				//log.Logf(0, "ConstArg addr: %x val: %x size: %v\n", *addr, (*arg).(*ConstArg).Val, (*arg).(*ConstArg).Size())
+			}
+		}
+		break
+	case *ResultArg:
+		if doWhat == UpdateProg {
+			if is_pointer != 0 {
+				if v, ok := res.ResPointer[*addr]; ok {
+					val := binary.LittleEndian.Uint64(v)
+					(*arg).(*ResultArg).Val = val
+				}
+				//log.Logf(0, "ResultArg addr: %x val: %x size: %v\n", *addr, (*arg).(*ResultArg).Val, (*arg).(*ResultArg).Size())
+				*addr += (*arg).(*ResultArg).Size()
+			} else {
+				size := target.ReadQWord(res.ResCall, deep)
+				data := target.ReadData(res.ResCall, size, deep)
+				val := binary.LittleEndian.Uint64(data)
+				(*arg).(*ResultArg).Val = val
+				//log.Logf(0, "ResultArg addr: %x val: %x size: %v\n", *addr, (*arg).(*ResultArg).Val, (*arg).(*ResultArg).Size())
+			}
+		}
+		break
+	case *PointerArg:
+		var val uint64
+		if doWhat == UpdateProg {
+			var NewAddr uint64
+			var isPointer uint64
+
+			if is_pointer != 0 {
+				if v, ok := res.ResPointer[*addr]; ok {
+					val := binary.LittleEndian.Uint64(v)
+					log.Logf(0, "Address %x, val %x\n", (*arg).(*PointerArg).Address, val)
+					if (*arg).(*PointerArg).Address > 0x20000000 {
+						(*arg).(*PointerArg).Address = val - 0x20000000
+					}
+				}
+			} else {
+				size := target.ReadQWord(res.ResCall, deep)
+				data := target.ReadData(res.ResCall, size, deep)
+				val = binary.LittleEndian.Uint64(data)
+			}
+			NewAddr = 0x20000000 + (*arg).(*PointerArg).Address
+			if is_pointer == 0 && NewAddr != val {
+				log.Logf(0, "Failed to parse PointerArg, expected %x, but got %x\n", val, NewAddr)
+				return
+			}
+			isPointer = 1
+			//log.Logf(0, "PointerArg addr: %x\n", 0x20000000+(*arg).(*PointerArg).Address)
+			target.Do(deep, doWhat, &NewAddr, &isPointer, &(*arg).(*PointerArg).Res, data)
+			*addr += (*arg).(*PointerArg).Size()
+		}
+		if doWhat == MakePInfo {
+			var newDeep int
+			var isPointer uint64
+			isPointer = 1
+			res := (*arg).(*PointerArg).Res
+			count := (*pInfo)[*deep].NumOfChildren
+			for i := *deep + 1; i < 625; i++ {
+				if (*pInfo)[i].IndexOfArgs == 0 {
+					newDeep = i
+					break
+				}
+			}
+			(*pInfo)[*deep].Children[count] = newDeep
+			(*pInfo)[*deep].NumOfChildren = count + 1
+			target.Do(&newDeep, doWhat, &indexOfCurrentArgs, &isPointer, &res, pInfo)
+		}
+		break
+	case *DataArg:
+		if doWhat == UpdateProg {
+			if is_pointer != 0 {
+				if _, ok := res.ResPointer[*addr]; ok {
+					copy((*arg).(*DataArg).data, res.ResPointer[*addr])
+				}
+				//log.Logf(0, "DataArg addr: %x val: %v size: %v\n", addr, (*arg).(*DataArg).data, (*arg).(*DataArg).Size())
+				*addr += (*arg).(*DataArg).Size()
+			} else {
+				size := target.ReadQWord(res.ResCall, deep)
+				data := target.ReadData(res.ResCall, size, deep)
+				copy((*arg).(*DataArg).data, data)
+				//log.Logf(0, "DataArg addr: %x val: %v size: %v\n", addr, (*arg).(*DataArg).data, (*arg).(*DataArg).Size())
+			}
+		}
+		break
+	case *GroupArg:
+		//log.Logf(0, "Enter GroupArg")
+		if doWhat == UpdateProg {
+			for i := 0; i < len((*arg).(*GroupArg).Inner); i++ {
+				target.Do(deep, doWhat, num1, num2, &(*arg).(*GroupArg).Inner[i], data)
+			}
+		}
+		if doWhat == MakePInfo {
+			var newIndexOfCurrentArgs uint64
+			for i, a := range (*arg).(*GroupArg).Inner {
+				newIndexOfCurrentArgs = indexOfCurrentArgs + uint64(i)
+				target.Do(deep, doWhat, &indexOfArgs, &newIndexOfCurrentArgs, &a, pInfo)
+			}
+		}
+		//log.Logf(0, "Exit GroupArg")
+		break
+	case *UnionArg:
+		//log.Logf(0, "UnionArg")
+		if doWhat == UpdateProg {
+			target.Do(deep, doWhat, num1, num2, &(*arg).(*UnionArg).Option, data)
+		}
+		if doWhat == MakePInfo {
+			target.Do(deep, doWhat, &indexOfArgs, &indexOfCurrentArgs, &(*arg).(*UnionArg).Option, pInfo)
+		}
+		break
+	default:
+		//log.Logf(0, "Nontype")
+		break
+	}
+}*/
+
+func (target *Target) ParseArgType(tab string, arg *Arg, export *[]byte) {
+	last := len(*export) - 1
+	if (*export)[last] != '{' {
+		*export = append(*export, ',')
+	}
+	switch (*arg).(type) {
+	case *ConstArg:
+		val := (*arg).(*ConstArg).Val
+		*export = append(*export, []byte("ConstArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):")...)
+		*export = append(*export, []byte(strconv.FormatUint(val, 10))...)
+		//*export += "ConstArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):" + strconv.FormatUint(val, 10)
+		log.Logf(0, "%s |ConstType %x\n", tab, val)
+	case *ResultArg:
+		val := (*arg).(*ResultArg).Val
+		//reg := (*arg).(*ResultArg).Res.Val
+		*export = append(*export, []byte("ResultArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):")...)
+		//*export += "ResultArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):"
+		/*if reg != "" {
+			*export = append(*export, []byte(reg)...)
+			//*export += reg
+		}*/
+		*export = append(*export, []byte(strconv.FormatUint(val, 10))...)
+		//*export += strconv.FormatUint(val, 10)
+		log.Logf(0, "%s |ResultArg %x\n", tab, val)
+	case *PointerArg:
+		*export = append(*export, []byte("PointerArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):{")...)
+		//*export += "PointerArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):\\{"
+		val := (*arg).(*PointerArg).Address
+		log.Logf(0, "%s |PointerArg %x\n", tab, val)
+		target.ParseArgType(tab+" | ", &(*arg).(*PointerArg).Res, export)
+		//*export += "\\}"
+		*export = append(*export, []byte("}")...)
+	case *DataArg:
+		val := (*arg).(*DataArg).data
+		*export = append(*export, []byte("DataArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):")...)
+		*export = append(*export, val...)
+		//*export += "DataArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):" + string(val)
+		log.Logf(0, "%s |DataArg %s\n", tab, val)
+	case *GroupArg:
+		*export = append(*export, []byte("GroupArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):{")...)
+		//*export += "GroupArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):\\{"
+		log.Logf(0, "%s |GroupArg \n", tab)
+		for i := 0; i < len((*arg).(*GroupArg).Inner); i++ {
+			target.ParseArgType(tab+" | ", &(*arg).(*GroupArg).Inner[i], export)
+		}
+		*export = append(*export, []byte("}")...)
+		//*export += "\\}"
+	case *UnionArg:
+		*export = append(*export, []byte("UnionArg(")...)
+		*export = append(*export, []byte(strconv.FormatUint((*arg).Size(), 10))...)
+		*export = append(*export, []byte("):{")...)
+		//*export += "UnionArg\\(" + strconv.FormatUint(arg.Size(), 10) + "\\):\\{"
+		log.Logf(0, "%s |UnionArg\n", tab)
+		target.ParseArgType(tab+" | ", &(*arg).(*UnionArg).Option, export)
+		*export = append(*export, []byte("}")...)
+		//*export += "\\}"
+	default:
+		log.Logf(0, "%s |NoneType", tab)
+	}
+
+}
+
 func (ctx *serializer) printf(text string, args ...interface{}) {
 	fmt.Fprintf(ctx.buf, text, args...)
 }
@@ -262,6 +515,7 @@ func (p *parser) parseProg() (*Prog, error) {
 		}
 		meta := p.target.SyscallMap[name]
 		if meta == nil {
+			MissingSyscall = name
 			return nil, fmt.Errorf("unknown syscall %v", name)
 		}
 		c := &Call{
diff --git a/prog/minimization.go b/prog/minimization.go
index 9a71dd06..e3f64e0c 100644
--- a/prog/minimization.go
+++ b/prog/minimization.go
@@ -31,7 +31,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 	p0, callIndex0 = removeCalls(p0, callIndex0, crash, pred)
 
 	// Try to minimize individual args.
-	for i := 0; i < len(p0.Calls); i++ {
+	for i := NOfCalls; i < len(p0.Calls); i++ {
 		ctx := &minimizeArgsCtx{
 			target:     p0.Target,
 			p0:         &p0,
@@ -60,7 +60,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 }
 
 func removeCalls(p0 *Prog, callIndex0 int, crash bool, pred func(*Prog, int) bool) (*Prog, int) {
-	for i := len(p0.Calls) - 1; i >= 0; i-- {
+	for i := len(p0.Calls) - 1; i >= NOfCalls; i-- {
 		if i == callIndex0 {
 			continue
 		}
diff --git a/prog/mutation.go b/prog/mutation.go
index 62acba58..db20d551 100644
--- a/prog/mutation.go
+++ b/prog/mutation.go
@@ -34,19 +34,24 @@ func (p *Prog) Mutate(rs rand.Source, ncalls int, ct *ChoiceTable, corpus []*Pro
 		corpus: corpus,
 	}
 	for stop, ok := false, false; !stop; stop = ok && len(p.Calls) != 0 && r.oneOf(3) {
+		if len(p.Calls) == NOfCalls {
+			ctx.insertCallAtEnd()
+		}
 		switch {
 		case r.oneOf(5):
 			// Not all calls have anything squashable,
 			// so this has lower priority in reality.
-			ok = ctx.squashAny()
+			ok = ctx.squashAnyCus()
 		case r.nOutOf(1, 100):
-			ok = ctx.splice()
+			ok = ctx.spliceCus()
 		case r.nOutOf(20, 31):
-			ok = ctx.insertCall()
+			ok = ctx.insertCallCus()
 		case r.nOutOf(10, 11):
-			ok = ctx.mutateArg()
+			ok = ctx.mutateArgCus()
 		default:
-			ok = ctx.removeCall()
+			if len(p.Calls) > NOfCalls {
+				ok = ctx.removeCallCus()
+			}
 		}
 	}
 	for _, c := range p.Calls {
diff --git a/prog/mutation_custom.go b/prog/mutation_custom.go
new file mode 100644
index 00000000..d6ff47ec
--- /dev/null
+++ b/prog/mutation_custom.go
@@ -0,0 +1,243 @@
+package prog
+
+import (
+	"fmt"
+	"strings"
+)
+
+var NOfCalls = 0
+var PocProg string
+var ExecutePoCOnly = true
+var LastGroupArg = ""
+var LastArg = ""
+var MissingSyscall = ""
+
+func (ctx *mutator) spliceCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.splice()
+	}
+	if len(ctx.corpus) == 0 || len(p.Calls)-NOfCalls <= 0 || len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	p0 := ctx.corpus[r.Intn(len(ctx.corpus))]
+	p0c := p0.Clone()
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.Calls = append(p.Calls[:idx], append(p0c.Calls, p.Calls[idx:]...)...)
+	for i := len(p.Calls) - 1; i >= ctx.ncalls; i-- {
+		p.removeCall(i)
+	}
+	return true
+}
+
+// Picks a random complex pointer and squashes its arguments into an ANY.
+// Subsequently, if the ANY contains blobs, mutates a random blob.
+func (ctx *mutator) squashAnyCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.squashAny()
+	}
+	complexPtrs := p.complexPtrsCus()
+	if len(complexPtrs) == 0 {
+		return false
+	}
+	ptr := complexPtrs[r.Intn(len(complexPtrs))]
+	if !p.Target.isAnyPtr(ptr.Type()) {
+		p.Target.squashPtr(ptr, true)
+	}
+	var blobs []*DataArg
+	var bases []*PointerArg
+	ForeachSubArg(ptr, func(arg Arg, ctx *ArgCtx) {
+		if data, ok := arg.(*DataArg); ok && arg.Type().Dir() != DirOut {
+			blobs = append(blobs, data)
+			bases = append(bases, ctx.Base)
+		}
+	})
+	if len(blobs) == 0 {
+		return false
+	}
+	// TODO(dvyukov): we probably want special mutation for ANY.
+	// E.g. merging adjacent ANYBLOBs (we don't create them,
+	// but they can appear in future); or replacing ANYRES
+	// with a blob (and merging it with adjacent blobs).
+	idx := r.Intn(len(blobs))
+	arg := blobs[idx]
+	base := bases[idx]
+	baseSize := base.Res.Size()
+	arg.data = mutateData(r, arg.Data(), 0, maxBlobLen)
+	// Update base pointer if size has increased.
+	if baseSize < base.Res.Size() {
+		s := analyze(ctx.ct, ctx.corpus, p, p.Calls[0])
+		newArg := r.allocAddr(s, base.Type(), base.Res.Size(), base.Res)
+		*base = *newArg
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallAtEnd() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return true
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := len(p.Calls)
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p, idx)
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.insertCall()
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := r.biasedRand(len(p.Calls)+1-NOfCalls, 5) + NOfCalls
+
+	if NOfCalls == len(p.Calls) {
+		idx = len(p.Calls)
+	}
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p, idx)
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+// Removes a random call from program.
+func (ctx *mutator) removeCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.removeCall()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.removeCall(idx)
+	return true
+}
+
+// Mutate an argument of a random call.
+func (ctx *mutator) mutateArgCus() bool {
+	start := NOfCalls
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.mutateArg()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := chooseCallCus(p, r, start)
+	if idx < 0 {
+		return false
+	}
+	c := p.Calls[idx]
+	updateSizes := true
+	for stop, ok := false, false; !stop; stop = ok && r.oneOf(3) {
+		ok = true
+		ma := &mutationArgs{target: p.Target}
+		ForeachArg(c, ma.collectArg)
+		if len(ma.args) == 0 {
+			return false
+		}
+		s := analyze(ctx.ct, ctx.corpus, p, c)
+		chosenIdx := randomChoice(ma.priorities, r)
+		arg, argCtx := ma.args[chosenIdx], ma.ctxes[chosenIdx]
+		calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &updateSizes)
+		if !ok1 {
+			ok = false
+			continue
+		}
+		p.insertBefore(c, calls)
+		idx += len(calls)
+		for len(p.Calls) > ctx.ncalls {
+			idx--
+			p.removeCall(idx)
+		}
+		if idx < 0 || idx >= len(p.Calls) || p.Calls[idx] != c {
+			panic(fmt.Sprintf("wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v",
+				idx, len(calls), len(p.Calls), ctx.ncalls))
+		}
+		if updateSizes {
+			p.Target.assignSizesCall(c)
+		}
+	}
+	return true
+}
+
+// Select a call based on the complexity of the arguments.
+func chooseCallCus(p *Prog, r *randGen, start int) int {
+	var callPriorities []float64
+	noArgs := true
+
+	for i, c := range p.Calls {
+		if i < start {
+			continue
+		}
+		totalPrio := float64(0)
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			prio, stopRecursion := arg.Type().getMutationPrio(p.Target, arg, false)
+			totalPrio += prio
+			ctx.Stop = stopRecursion
+		})
+		callPriorities = append(callPriorities, totalPrio)
+		if len(c.Args) > 0 {
+			noArgs = false
+		}
+	}
+
+	// Calls without arguments.
+	if noArgs {
+		return -1
+	}
+	return start + randomChoice(callPriorities, r)
+}
+
+func (p *Prog) complexPtrsCus() (res []*PointerArg) {
+	for i, c := range p.Calls {
+		if i < NOfCalls {
+			continue
+		}
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			if ptrArg, ok := arg.(*PointerArg); ok && p.Target.isComplexPtr(ptrArg) {
+				res = append(res, ptrArg)
+				ctx.Stop = true
+			}
+		})
+	}
+	return
+}
+
+func containPoC(prog []byte) bool {
+	if !ExecutePoCOnly {
+		return false
+	}
+	sProg := string(prog)
+	if len(sProg) < len(PocProg) {
+		return false
+	}
+
+	if strings.Compare(PocProg, sProg[:len(PocProg)]) == 0 {
+		return true
+	}
+	return false
+}
diff --git a/prog/rand.go b/prog/rand.go
index bf6d66e9..407a3e83 100644
--- a/prog/rand.go
+++ b/prog/rand.go
@@ -14,6 +14,7 @@ import (
 
 	"github.com/google/syzkaller/pkg/ifuzz"
 	_ "github.com/google/syzkaller/pkg/ifuzz/generated" // pull in generated instruction descriptions
+	"github.com/google/syzkaller/pkg/log"
 )
 
 const (
@@ -700,7 +701,13 @@ func (a *ResourceType) generate(r *randGen, s *state) (arg Arg, calls []*Call) {
 			return
 		}
 	}
+	// Using previouse generated fd makes more sense for triggering PoC
+	arg = r.existingResource(s, a)
+	if arg != nil {
+		return
+	}
 	special := a.SpecialValues()
+	log.Logf(1, "No existingResource found, using SpecialValues: %x", special)
 	arg = MakeResultArg(a, nil, special[r.Intn(len(special))])
 	return
 }
diff --git a/prog/validation.go b/prog/validation.go
index c8c030aa..d6923aca 100644
--- a/prog/validation.go
+++ b/prog/validation.go
@@ -95,6 +95,24 @@ func (ctx *validCtx) validateArg(arg Arg, typ Type) error {
 		return fmt.Errorf("bad arg type %#v, expect %#v", arg.Type(), typ)
 	}
 	ctx.args[arg] = true
+	switch arg.(type) {
+	case *ConstArg:
+		LastArg = arg.Type().Name()
+		break
+	case *ResultArg:
+		LastArg = arg.Type().Name()
+		break
+	case *PointerArg:
+		LastArg = arg.Type().Name()
+		break
+	case *DataArg:
+		LastArg = arg.Type().Name()
+		break
+	case *GroupArg:
+		LastGroupArg = arg.Type().Name()
+		break
+	default:
+	}
 	return arg.validate(ctx)
 }
 
@@ -206,6 +224,7 @@ func (arg *GroupArg) validate(ctx *validCtx) error {
 	default:
 		return fmt.Errorf("group arg %v has bad type %v", arg, typ.Name())
 	}
+	LastGroupArg = ""
 	return nil
 }
 
diff --git a/syz-fuzzer/fuzzer.go b/syz-fuzzer/fuzzer.go
index b6e8be4b..bcab28bd 100644
--- a/syz-fuzzer/fuzzer.go
+++ b/syz-fuzzer/fuzzer.go
@@ -102,6 +102,8 @@ const (
 	OutputFile
 )
 
+var lastEnqueue time.Time
+
 func main() {
 	debug.SetGCPercent(50)
 
@@ -115,6 +117,7 @@ func main() {
 		flagPprof   = flag.String("pprof", "", "address to serve pprof profiles")
 		flagTest    = flag.Bool("test", false, "enable image testing mode")      // used by syz-ci
 		flagRunTest = flag.Bool("runtest", false, "enable program testing mode") // used by pkg/runtest
+		flagPoC     = flag.Bool("poc", false, "mutate base on current PoC")
 	)
 	flag.Parse()
 	outputType := parseOutputType(*flagOutput)
@@ -247,6 +250,7 @@ func main() {
 	for _, id := range r.CheckResult.EnabledCalls[sandbox] {
 		calls[target.Syscalls[id]] = true
 	}
+	go fuzzer.sendCallsToManager(r.CheckResult.EnabledCalls, sandbox)
 	prios := target.CalculatePriorities(fuzzer.corpus)
 	fuzzer.choiceTable = target.BuildChoiceTable(prios, calls)
 
@@ -259,6 +263,13 @@ func main() {
 		go proc.loop()
 	}
 
+	MutatingLoop, err1 := newProc(fuzzer, *flagProcs)
+	if err1 != nil {
+		log.Fatalf("failed to create proc: %v", err)
+	}
+	fuzzer.procs = append(fuzzer.procs, MutatingLoop)
+	go MutatingLoop.checkMutatingQueueLoop()
+	prog.ExecutePoCOnly = *flagPoC
 	fuzzer.pollLoop()
 }
 
@@ -315,6 +326,7 @@ func (fuzzer *Fuzzer) pollLoop() {
 	var lastPoll time.Time
 	var lastPrint time.Time
 	ticker := time.NewTicker(3 * time.Second).C
+	lastEnqueue = time.Now()
 	for {
 		poll := false
 		select {
@@ -327,6 +339,11 @@ func (fuzzer *Fuzzer) pollLoop() {
 			log.Logf(0, "alive, executed %v", execTotal)
 			lastPrint = time.Now()
 		}
+		if time.Since(lastEnqueue) > 4*time.Minute && time.Since(lastEnqueue) < 5*time.Minute && prog.ExecutePoCOnly && len(fuzzer.workQueue.triageCandidate)+len(fuzzer.workQueue.candidate)+len(fuzzer.workQueue.triage)+len(fuzzer.workQueue.smash)+len(fuzzer.workQueue.grow) == 0 {
+			//log.Logf(0, "set fuzzer free")
+			//fuzzer.sendSignal("set fuzzer free")
+			//prog.ExecutePoCOnly = false
+		}
 		if poll || time.Since(lastPoll) > 10*time.Second {
 			needCandidates := fuzzer.workQueue.wantCandidates()
 			if poll && !needCandidates {
@@ -367,9 +384,11 @@ func (fuzzer *Fuzzer) poll(needCandidates bool, stats map[string]uint64) bool {
 	for _, inp := range r.NewInputs {
 		fuzzer.addInputFromAnotherFuzzer(inp)
 	}
+	//if !prog.ExecutePoCOnly {
 	for _, candidate := range r.Candidates {
 		fuzzer.addCandidateInput(candidate)
 	}
+	//}
 	if needCandidates && len(r.Candidates) == 0 && atomic.LoadUint32(&fuzzer.triagedCandidates) == 0 {
 		atomic.StoreUint32(&fuzzer.triagedCandidates, 1)
 	}
@@ -541,3 +560,23 @@ func parseOutputType(str string) OutputType {
 		return OutputNone
 	}
 }
+
+func (fuzzer *Fuzzer) sendSignal(sg string) {
+	a := &rpctype.FuzzerSignal{
+		Signal: sg,
+	}
+	r := &rpctype.FuzzerSignal{}
+	if err := fuzzer.manager.Call("Manager.EmitSignal", a, r); err != nil {
+		log.Fatalf("emitSignal: failed to connect to manager: %v ", err)
+	}
+}
+
+func (fuzzer *Fuzzer) sendCallsToManager(enabledCalls map[string][]int, sandbox string) {
+	a := &rpctype.GetCallsFromFuzzerArgs{
+		EnabledCalls: enabledCalls,
+		Sandbox:      sandbox,
+	}
+	if err := fuzzer.manager.Call("Manager.GetCallsFromFuzzer", a, nil); err != nil {
+		log.Fatalf("Manager.GetCallsFromFuzzer call failed: %v", err)
+	}
+}
diff --git a/syz-fuzzer/proc.go b/syz-fuzzer/proc.go
index d815a58b..9151ad87 100644
--- a/syz-fuzzer/proc.go
+++ b/syz-fuzzer/proc.go
@@ -13,6 +13,7 @@ import (
 	"syscall"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/hash"
 	"github.com/google/syzkaller/pkg/ipc"
@@ -76,12 +77,17 @@ func (proc *Proc) loop() {
 				proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)
 			case *WorkSmash:
 				proc.smashInput(item)
+			case *WorkGrow:
+				proc.growInput(proc.execOpts, item, StatCandidate)
 			default:
 				log.Fatalf("unknown work type: %#v", item)
 			}
 			continue
 		}
 
+		//if prog.ExecutePoCOnly {
+		continue
+		//}
 		ct := proc.fuzzer.choiceTable
 		fuzzerSnapshot := proc.fuzzer.snapshot()
 		if len(fuzzerSnapshot.corpus) == 0 || i%generatePeriod == 0 {
@@ -177,6 +183,18 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 	}
 }
 
+func (proc *Proc) growInput(execOpts *ipc.ExecOpts, item *WorkGrow, stat Stat) {
+	log.Logf(1, "#%v: growInput type=%x", proc.pid, item.flags)
+
+	proc.executeRaw(execOpts, item.p, stat)
+	fuzzerSnapshot := proc.fuzzer.snapshot()
+	for i := 0; i < 500; i++ {
+		p := item.p.Clone()
+		p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, fuzzerSnapshot.corpus)
+		proc.execute(proc.execOpts, p, ProgNormal, StatSmash)
+	}
+}
+
 func reexecutionSuccess(info *ipc.ProgInfo, oldInfo *ipc.CallInfo, call int) bool {
 	if info == nil || len(info.Calls) == 0 {
 		return false
@@ -208,7 +226,7 @@ func (proc *Proc) smashInput(item *WorkSmash) {
 		proc.executeHintSeed(item.p, item.call)
 	}
 	fuzzerSnapshot := proc.fuzzer.snapshot()
-	for i := 0; i < 100; i++ {
+	for i := 0; i < 500; i++ {
 		p := item.p.Clone()
 		p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, fuzzerSnapshot.corpus)
 		log.Logf(1, "#%v: smash mutated", proc.pid)
@@ -250,7 +268,10 @@ func (proc *Proc) executeHintSeed(p *prog.Prog, call int) {
 func (proc *Proc) execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo {
 	info := proc.executeRaw(execOpts, p, stat)
 	calls, extra := proc.fuzzer.checkNewSignal(p, info)
-	for _, callIndex := range calls {
+	for i, callIndex := range calls {
+		if i < prog.NOfCalls {
+			continue
+		}
 		proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])
 	}
 	if extra {
@@ -343,3 +364,41 @@ func (proc *Proc) logProgram(opts *ipc.ExecOpts, p *prog.Prog) {
 		log.Fatalf("unknown output type: %v", proc.fuzzer.outputType)
 	}
 }
+
+func (proc *Proc) checkMutatingQueueLoop() {
+	for {
+		a := &rpctype.GetQueueLenArgs{
+			Flag: courier.Mutating,
+		}
+		r := &rpctype.GetQueueLenRes{}
+		if err := proc.fuzzer.manager.Call("Manager.GetQueueLen", a, r); err != nil {
+			log.Fatalf("checkArgsQueueLoop: failed to connect to manager: %v ", err)
+		}
+		if r.Length > 0 {
+			pq := &rpctype.ProgQueue{}
+			if err := proc.fuzzer.manager.Call("Manager.RetrieveArgsQueue", pq, pq); err != nil {
+				log.Fatalf("failed to connect to manager: %v ", err)
+			}
+			log.Logf(1, "New Arg Aviable: %s\n", pq.Prog)
+			p, err := proc.fuzzer.target.Deserialize(pq.Prog, prog.NonStrict)
+			if err != nil {
+				log.Fatalf("checkArgsQueueLoop: failed to parse program from manager: %v", err)
+			}
+			//sig := hash.Hash(pq.Prog)
+			//sign := pq.Prog.Signal.Deserialize()
+			//fuzzer.addInputToCorpus(p, sign, sig)
+			flags := ProgNormal
+			prog.NOfCalls = pq.NOfCalls
+			prog.PocProg = string(pq.PocProg)
+			//if strings.Compare(string(pq.Prog), string(p.Serialize())) != 0 {
+			//prog.PocProg = string(p.Serialize())
+			//	log.Logf(0, "Prog is not minimized\n")
+			//}
+			proc.fuzzer.workQueue.enqueue(&WorkGrow{
+				p:     p,
+				flags: flags,
+			})
+		}
+		time.Sleep(10 * time.Second)
+	}
+}
diff --git a/syz-fuzzer/testing.go b/syz-fuzzer/testing.go
index 960a1fd2..e0b89ca8 100644
--- a/syz-fuzzer/testing.go
+++ b/syz-fuzzer/testing.go
@@ -183,7 +183,8 @@ func checkMachine(args *checkArgs) (*rpctype.CheckArgs, error) {
 }
 
 func checkRevisions(args *checkArgs) error {
-	log.Logf(0, "checking revisions...")
+	//log.Logf(0, "checking revisions!...")
+	log.Logf(0, "checkRevisions prog.GitRevision %v", prog.GitRevision)
 	executorArgs := strings.Split(args.ipcConfig.Executor, " ")
 	executorArgs = append(executorArgs, "version")
 	cmd := osutil.Command(executorArgs[0], executorArgs[1:]...)
diff --git a/syz-fuzzer/workqueue.go b/syz-fuzzer/workqueue.go
index 62648336..e31b664a 100644
--- a/syz-fuzzer/workqueue.go
+++ b/syz-fuzzer/workqueue.go
@@ -5,6 +5,7 @@ package main
 
 import (
 	"sync"
+	"time"
 
 	"github.com/google/syzkaller/pkg/ipc"
 	"github.com/google/syzkaller/prog"
@@ -20,6 +21,7 @@ type WorkQueue struct {
 	candidate       []*WorkCandidate
 	triage          []*WorkTriage
 	smash           []*WorkSmash
+	grow            []*WorkGrow
 
 	procs          int
 	needCandidates chan struct{}
@@ -61,6 +63,11 @@ type WorkSmash struct {
 	call int
 }
 
+type WorkGrow struct {
+	p     *prog.Prog
+	flags ProgTypes
+}
+
 func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 	return &WorkQueue{
 		procs:          procs,
@@ -71,6 +78,7 @@ func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 func (wq *WorkQueue) enqueue(item interface{}) {
 	wq.mu.Lock()
 	defer wq.mu.Unlock()
+	lastEnqueue = time.Now()
 	switch item := item.(type) {
 	case *WorkTriage:
 		if item.flags&ProgCandidate != 0 {
@@ -82,6 +90,8 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 		wq.candidate = append(wq.candidate, item)
 	case *WorkSmash:
 		wq.smash = append(wq.smash, item)
+	case *WorkGrow:
+		wq.grow = append(wq.grow, item)
 	default:
 		panic("unknown work type")
 	}
@@ -89,7 +99,7 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 
 func (wq *WorkQueue) dequeue() (item interface{}) {
 	wq.mu.RLock()
-	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash) == 0 {
+	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash)+len(wq.grow) == 0 {
 		wq.mu.RUnlock()
 		return nil
 	}
@@ -113,6 +123,10 @@ func (wq *WorkQueue) dequeue() (item interface{}) {
 		last := len(wq.smash) - 1
 		item = wq.smash[last]
 		wq.smash = wq.smash[:last]
+	} else if len(wq.grow) != 0 {
+		last := len(wq.grow) - 1
+		item = wq.grow[last]
+		wq.grow = wq.grow[:last]
 	}
 	wq.mu.Unlock()
 	if wantCandidates {
diff --git a/syz-manager/manager.go b/syz-manager/manager.go
index 2a0b7dd4..240577bb 100644
--- a/syz-manager/manager.go
+++ b/syz-manager/manager.go
@@ -6,6 +6,7 @@ package main
 import (
 	"bytes"
 	"encoding/json"
+	"errors"
 	"flag"
 	"fmt"
 	"math/rand"
@@ -13,10 +14,13 @@ import (
 	"os"
 	"os/exec"
 	"path/filepath"
+	"strconv"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/dashboard/dashapi"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/csource"
@@ -41,8 +45,11 @@ var (
 	flagConfig = flag.String("config", "", "configuration file")
 	flagDebug  = flag.Bool("debug", false, "dump all VM output to console")
 	flagBench  = flag.String("bench", "", "write execution statistics into this file periodically")
+	flagPoC    = flag.Bool("poc", false, "mutate base on current PoC")
 )
 
+var shutdownErr = errors.New("An error to shutdown all vms")
+
 type Manager struct {
 	cfg            *mgrconfig.Config
 	vmPool         *vm.Pool
@@ -102,6 +109,13 @@ const (
 	phaseTriagedHub
 )
 
+const (
+	nonCritical = 0
+	abMemRead   = 1
+	abMemWrite  = 2
+	invalidFree = 4
+)
+
 const currentDBVersion = 4
 
 type Crash struct {
@@ -201,7 +215,9 @@ func RunManager(cfg *mgrconfig.Config, target *prog.Target, sysTarget *targets.T
 	}
 
 	go func() {
+		c := 0
 		for lastTime := time.Now(); ; {
+			c += 1
 			time.Sleep(10 * time.Second)
 			now := time.Now()
 			diff := now.Sub(lastTime)
@@ -267,6 +283,8 @@ func RunManager(cfg *mgrconfig.Config, target *prog.Target, sysTarget *targets.T
 		<-vm.Shutdown
 		return
 	}
+	TestcasePath = cfg.Testcase
+	courier.AnalyzerPath = cfg.AnalyzerDir
 	mgr.vmLoop()
 }
 
@@ -311,6 +329,13 @@ func (mgr *Manager) vmLoop() {
 	reproDone := make(chan *ReproResult, 1)
 	stopPending := false
 	shutdown := vm.Shutdown
+	succeed := 0
+	start := time.Now()
+	storeRead := mgr.cfg.StoreRead
+	if storeRead {
+		log.Logf(0, "storeRead %v", storeRead)
+	}
+	report.ReadIsCritical = storeRead
 	for shutdown != nil || len(instances) != vmCount {
 		mgr.mu.Lock()
 		phase := mgr.phase
@@ -339,6 +364,11 @@ func (mgr *Manager) vmLoop() {
 		}
 
 		if shutdown != nil {
+			executed := mgr.stats.execTotal.get()
+			if executed <= 1 && time.Since(start).Seconds() > 300 && len(reproducing) == 0 {
+				log.Logf(0, "Restart syzkaller to avoid one executed")
+				os.Exit(4)
+			}
 			for canRepro() && len(instances) >= instancesPerRepro {
 				last := len(reproQueue) - 1
 				crash := reproQueue[last]
@@ -367,7 +397,14 @@ func (mgr *Manager) vmLoop() {
 				instances = instances[:last]
 				log.Logf(1, "loop: starting instance %v", idx)
 				go func() {
-					crash, err := mgr.runInstance(idx)
+					timeLimit, err := strconv.Atoi(mgr.cfg.TimeLimit)
+					if err != nil {
+						timeLimit = 8
+					}
+					crash, err := mgr.runInstance(idx, start, timeLimit)
+					if (err == shutdownErr || succeed > 5) && crash == nil && len(reproQueue)+len(pendingRepro)+len(reproducing) == 0 {
+						shutdown = nil
+					}
 					runDone <- &RunResult{idx, crash, err}
 				}()
 			}
@@ -387,6 +424,10 @@ func (mgr *Manager) vmLoop() {
 			stopPending = true
 		case res := <-runDone:
 			log.Logf(1, "loop: instance %v finished, crash=%v", res.idx, res.crash != nil)
+			if *flagPoC && res.crash != nil && res.crash.Report.Title == vm.NoOutputCrash {
+				log.Logf(0, "exit due to no output for a long time")
+				shutdown = nil
+			}
 			if res.err != nil && shutdown != nil {
 				log.Logf(0, "%v", res.err)
 			}
@@ -396,12 +437,19 @@ func (mgr *Manager) vmLoop() {
 			// which we detect as "lost connection". Don't save that as crash.
 			if shutdown != nil && res.crash != nil {
 				needRepro := mgr.saveCrash(res.crash)
-				if needRepro {
-					log.Logf(1, "loop: add pending repro for '%v'", res.crash.Title)
-					pendingRepro[res.crash] = true
+				if isCriticalCrash(res.crash.Report.Title, storeRead) > 0 {
+					if needRepro && succeed <= 5 && res.crash.Report.Title != vm.NoOutputCrash && res.crash.Report.Title != "lost connection to test machine" {
+						log.Logf(1, "loop: add pending repro for '%v'", res.crash.Title)
+						pendingRepro[res.crash] = true
+					}
 				}
 			}
 		case res := <-reproDone:
+			if res.res != nil && isCriticalCrash(res.res.Report.Title, storeRead) != nonCritical {
+				prog := res.res.Prog.Serialize()
+				courier.AppendCriticalPoCQueue(prog)
+				flagExtraMutating = true
+			}
 			atomic.AddUint32(&mgr.numReproducing, ^uint32(0))
 			crepro := false
 			title := ""
@@ -423,6 +471,28 @@ func (mgr *Manager) vmLoop() {
 				}
 			} else {
 				mgr.saveRepro(res.res, res.stats, res.hub)
+				log.Logf(0, "SaveRepro %s", res.res.Report.Title)
+				if isCriticalCrash(res.res.Report.Title, storeRead) != nonCritical {
+					succeed++
+				}
+				if (isCriticalCrash(res.res.Report.Title, storeRead) & abMemWrite) != nonCritical {
+					if succeed == 1 {
+						log.Logf(0, "Save to success file")
+						courier.SaveToFile("AbnormallyMemWrite")
+					}
+				}
+				if (isCriticalCrash(res.res.Report.Title, storeRead) & abMemRead) != nonCritical {
+					if succeed == 1 {
+						log.Logf(0, "Abnormally memory read found")
+						courier.SaveToFile("AbnormallyMemRead")
+					}
+				}
+				if (isCriticalCrash(res.res.Report.Title, storeRead) & invalidFree) != nonCritical {
+					if succeed == 1 {
+						log.Logf(0, "double free or invalid free")
+						courier.SaveToFile("DoubleFree")
+					}
+				}
 			}
 		case <-shutdown:
 			log.Logf(1, "loop: shutting down...")
@@ -528,7 +598,7 @@ func (mgr *Manager) loadCorpus() {
 	mgr.phase = phaseLoadedCorpus
 }
 
-func (mgr *Manager) runInstance(index int) (*Crash, error) {
+func (mgr *Manager) runInstance(index int, managerStart time.Time, timeLimit int) (*Crash, error) {
 	mgr.checkUsedFiles()
 	inst, err := mgr.vmPool.Create(index)
 	if err != nil {
@@ -569,14 +639,18 @@ func (mgr *Manager) runInstance(index int) (*Crash, error) {
 	defer atomic.AddUint32(&mgr.numFuzzing, ^uint32(0))
 	cmd := instance.FuzzerCmd(fuzzerBin, executorCmd, fmt.Sprintf("vm-%v", index),
 		mgr.cfg.TargetOS, mgr.cfg.TargetArch, fwdAddr, mgr.cfg.Sandbox, procs, fuzzerV,
-		mgr.cfg.Cover, *flagDebug, false, false)
+		mgr.cfg.Cover, *flagDebug, false, false, *flagPoC)
 	outc, errc, err := inst.Run(time.Hour, mgr.vmStop, cmd)
 	if err != nil {
 		return nil, fmt.Errorf("failed to run fuzzer: %v", err)
 	}
+	prog.ExecutePoCOnly = *flagPoC
 
-	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)
+	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout, managerStart, timeLimit)
 	if rep == nil {
+		if time.Since(managerStart) >= time.Duration(timeLimit)*time.Hour {
+			return nil, shutdownErr
+		}
 		// This is the only "OK" outcome.
 		log.Logf(0, "vm-%v: running for %v, restarting", index, time.Since(start))
 		return nil, nil
@@ -845,6 +919,12 @@ func (mgr *Manager) saveRepro(res *repro.Result, stats *repro.Stats, hub bool) {
 	if len(cprogText) > 0 {
 		osutil.WriteFile(filepath.Join(dir, "repro.cprog"), cprogText)
 	}
+	if len(res.Command) > 0 {
+		command := strings.Split(res.Command, " ")
+		command[len(command)-1] = "testcase"
+		newCommand := strings.Join(command, " ")
+		osutil.WriteFile(filepath.Join(dir, "repro.command"), []byte(newCommand))
+	}
 	saveReproStats(filepath.Join(dir, "repro.stats"), stats)
 }
 
@@ -1187,3 +1267,28 @@ func publicWebAddr(addr string) string {
 	}
 	return "http://" + addr
 }
+
+// return
+// 0 for Non-critical
+// 1 for Read
+// 2 for Write
+// 4 for invalid free
+func isCriticalCrash(title string, storeRead bool) int {
+	ret := nonCritical
+	if storeRead {
+		if strings.Contains(title, "out-of-bounds Read") ||
+			strings.Contains(title, "use-after-free Read") {
+			ret |= abMemRead
+		}
+	}
+
+	if strings.Contains(title, "out-of-bounds Write") ||
+		strings.Contains(title, "use-after-free Write") {
+		ret |= abMemWrite
+	}
+
+	if strings.Contains(title, "invalid-free in") {
+		ret |= invalidFree
+	}
+	return ret
+}
diff --git a/syz-manager/rpc.go b/syz-manager/rpc.go
index 91e31dbd..19e92b93 100644
--- a/syz-manager/rpc.go
+++ b/syz-manager/rpc.go
@@ -7,9 +7,11 @@ import (
 	"fmt"
 	"math/rand"
 	"net"
+	"os"
 	"sync"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/rpctype"
@@ -54,6 +56,7 @@ type RPCManagerView interface {
 	newInput(inp rpctype.RPCInput, sign signal.Signal) bool
 	candidateBatch(size int) []rpctype.RPCCandidate
 	rotateCorpus() bool
+	parseCustomizedTestcase(a rpctype.GetCallsFromFuzzerArgs, ch chan int)
 }
 
 func startRPCServer(mgr *Manager) (int, error) {
@@ -309,3 +312,50 @@ func (serv *RPCServer) Poll(a *rpctype.PollArgs, r *rpctype.PollRes) error {
 		a.Name, len(r.Candidates), len(r.NewInputs), len(r.MaxSignal.Elems))
 	return nil
 }
+
+func (serv *RPCServer) GetQueueLen(a *rpctype.GetQueueLenArgs, r *rpctype.GetQueueLenRes) error {
+	switch a.Flag {
+	case courier.Mutating:
+		r.Length = len(courier.MutateArgsQueue)
+		break
+	case courier.Commands:
+		r.Length = len(courier.CommandsQueue)
+		break
+	case courier.S2E:
+		r.Length = len(courier.S2EArgsQueue)
+	}
+	return nil
+}
+
+func (serv *RPCServer) RetrieveArgsQueue(a *rpctype.ProgQueue, pq *rpctype.ProgQueue) error {
+	courier.Mutex.Lock()
+	p := courier.RetrieveFirstArg(courier.Mutating)
+	if p != nil {
+		*pq = p.(rpctype.ProgQueue)
+	}
+	courier.Mutex.Unlock()
+	return nil
+}
+
+func (serv *RPCServer) EmitSignal(a *rpctype.FuzzerSignal, pq *rpctype.FuzzerSignal) error {
+	courier.Mutex.Lock()
+	sg := a.Signal
+	log.Logf(0, "A signal from fuzzer: %s\n", sg)
+	courier.Mutex.Unlock()
+	return nil
+}
+
+func (serv *RPCServer) GetCallsFromFuzzer(a *rpctype.GetCallsFromFuzzerArgs, r *int) error {
+	ch := make(chan int)
+
+	go serv.mgr.parseCustomizedTestcase(*a, ch)
+	exitcode := <-ch
+	if exitcode == -1 {
+		os.Exit(3)
+	}
+	/*err := serv.mgr.parseCustomizedTestcase(*a)
+	if err != nil {
+		log.Logf(0, "%v", err)
+	}*/
+	return nil
+}
diff --git a/syz-manager/utilities.go b/syz-manager/utilities.go
new file mode 100644
index 00000000..097a4cde
--- /dev/null
+++ b/syz-manager/utilities.go
@@ -0,0 +1,120 @@
+package main
+
+import (
+	"io/ioutil"
+	"math/rand"
+	_ "net/http/pprof"
+	"os"
+	"time"
+
+	"github.com/google/syzkaller/courier"
+	"github.com/google/syzkaller/pkg/log"
+	"github.com/google/syzkaller/pkg/rpctype"
+	"github.com/google/syzkaller/prog"
+)
+
+var TestcasePath string
+var flagParseTestcase = false
+var flagExtraMutating = false
+
+//Read and parse testcase, send it to fuzzer
+func (mgr *Manager) parseCustomizedTestcase(a rpctype.GetCallsFromFuzzerArgs, ch chan int) {
+	if flagParseTestcase {
+		ch <- 0
+		return
+	}
+	flagParseTestcase = true
+	var corpus []*prog.Prog
+	info, err := os.Stat(TestcasePath)
+	if !os.IsNotExist(err) {
+		if !info.IsDir() {
+			fileCache, err := os.Open(TestcasePath)
+			if err != nil {
+				log.Logf(0, "Error occur at parseCustomizedTestcase: %v\n", err)
+				ch <- 1
+				return
+			}
+			defer fileCache.Close()
+			testcase_raw, err := ioutil.ReadFile(TestcasePath)
+			if err != nil {
+				log.Logf(0, "Error occur at parseCustomizedTestcase: %v\n", err)
+				ch <- 1
+				return
+			}
+			testcase := courier.RemoveComments(testcase_raw)
+			log.Logf(0, "testcase: %s\n", testcase)
+			calls := make(map[*prog.Syscall]bool)
+			rnd := rand.New(rand.NewSource(time.Now().UnixNano() + int64(4)*1e12))
+			for _, id := range a.EnabledCalls[a.Sandbox] {
+				calls[mgr.target.Syscalls[id]] = true
+			}
+			prios := mgr.target.CalculatePriorities(corpus)
+			choiceTable := mgr.target.BuildChoiceTable(prios, calls)
+
+			p, err := mgr.target.Deserialize(testcase, prog.NonStrict)
+			if err != nil {
+				createTemplatePatch(mgr.cfg.Syzkaller)
+				log.Logf(0, "Fail to parse testcase: %v\n", err)
+				ch <- -1
+				return
+			}
+			prog.NOfCalls = len(p.Calls)
+			prog.PocProg = string(testcase)
+			courier.AppendTestcase(testcase, testcase, prog.NOfCalls)
+			for i := 1; i < 500; i++ {
+				p := p.Clone()
+				p.Mutate(rnd, prog.RecommendedCalls, choiceTable, corpus)
+				courier.AppendTestcase(p.Serialize(), []byte(prog.PocProg), prog.NOfCalls)
+			}
+			rnd = rand.New(rand.NewSource(time.Now().UnixNano() + int64(4)*1e12))
+			if !prog.ExecutePoCOnly {
+				for {
+					p := p.Clone()
+					p.Mutate(rnd, prog.RecommendedCalls, choiceTable, corpus)
+					courier.AppendTestcase(p.Serialize(), []byte(prog.PocProg), prog.NOfCalls)
+					time.Sleep(1 * time.Second)
+					if flagExtraMutating {
+						mgr.doExtraMutate(choiceTable, corpus)
+						flagExtraMutating = false
+					}
+				}
+			}
+			ch <- 0
+			return
+		}
+	}
+	log.Logf(0, "Error occur at parseCustomizedTestcase: %v\n", err)
+	return
+}
+
+func (mgr *Manager) doExtraMutate(choiceTable *prog.ChoiceTable, corpus []*prog.Prog) {
+	log.Logf(0, "doExtraMutate")
+	pq := courier.RetrieveFirstArg(courier.Critical)
+	if pq != nil {
+		testcase := pq.(rpctype.ProgQueue).Prog
+		oriP, err := mgr.target.Deserialize(testcase, prog.NonStrict)
+		if err != nil {
+			return
+		}
+		rnd := rand.New(rand.NewSource(time.Now().UnixNano() + int64(4)*1e12))
+		for i := 1; i < 500; i++ {
+			p := oriP.Clone()
+			p.Mutate(rnd, prog.RecommendedCalls, choiceTable, corpus)
+			courier.AppendTestcase(p.Serialize(), testcase, len(oriP.Calls))
+		}
+	}
+}
+
+func createTemplatePatch(base string) {
+	f, err := os.Create(base + "/CorrectTemplate")
+	if err != nil {
+		log.Logf(0, "Fail to open CorrectTemplate: %v\n", err)
+	}
+	defer f.Close()
+	if prog.MissingSyscall != "" {
+		f.Write([]byte("syscall:" + prog.MissingSyscall))
+	}
+	if prog.LastGroupArg != "" {
+		f.Write([]byte("arg:" + prog.LastGroupArg))
+	}
+}
diff --git a/tools/syz-branch2addr/syz-branch2addr.go b/tools/syz-branch2addr/syz-branch2addr.go
new file mode 100644
index 00000000..c5dbe4c2
--- /dev/null
+++ b/tools/syz-branch2addr/syz-branch2addr.go
@@ -0,0 +1,338 @@
+package main
+
+import (
+	"bufio"
+	"bytes"
+	"crypto/md5"
+	"encoding/hex"
+	"encoding/json"
+	"flag"
+	"fmt"
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+
+	"github.com/google/syzkaller/pkg/osutil"
+	"github.com/google/syzkaller/pkg/symbolizer"
+)
+
+type Range struct {
+	Funcname string
+	Start    uint64
+	End      uint64
+	File     string
+	Line     int
+	Found    bool
+}
+
+type BranchNode struct {
+	followBy uint64
+	jumpTo   uint64
+}
+
+type TraceInfo struct {
+	File string
+	Line int
+}
+
+type Trace struct {
+	condJump    TraceInfo
+	correctPath TraceInfo
+	wrongPath   TraceInfo
+}
+
+var branch map[uint64]map[string]uint64
+var trace []Trace
+
+func main() {
+	var (
+		f_funcname    = flag.String("f", "", "Funcname")
+		f_vmlinuxPath = flag.String("v", "", "Path to vmlinux")
+		f_rawformat   = flag.Bool("r", false, "Parsing the raw vmlinux.")
+		f_dCache      = flag.String("d", "", "Delete an cache, follow by the path to vmlinux")
+		f_usage       = flag.Bool("u", false, "Get the usage")
+		f_strict      = flag.Bool("s", false, "Strictly match")
+		fTrace        = flag.String("t", "", "Path to trace file")
+		targetOS      = flag.String("-os", "linux", "OS of target, default as linux")
+		targetArch    = flag.String("-arch", "amd64", "arch of target, default as amd64")
+	)
+	flag.Parse()
+	if (*f_vmlinuxPath == "" && *f_dCache == "" && *fTrace == "") || (*f_usage) {
+		fmt.Printf("Usage:  syz-func2addr [-r] [-d path_of_vmlinux] [-f funcname [-v path_of_vmlinux]]\n    eg. syz-func2addr -f snprintf_int_array -v /home/user/linux/vmlinux -r -s\n")
+		return
+	}
+	if !buildTrace(*fTrace) {
+		fmt.Printf("Fail to build trace")
+		return
+	}
+	branch = make(map[uint64]map[string]uint64)
+	var n uint64
+	n = 0
+	var list []Range
+	list = append(list, Range{Start: 0x0, End: 0x0, Found: false})
+
+	cache_exist, cache_path := isCacheExist(*f_dCache, *f_vmlinuxPath)
+	if *f_dCache != "" {
+		if cache_exist {
+			_ = os.Remove(cache_path)
+		}
+		return
+	}
+
+	var frames []symbolizer.Frame
+	if cache_exist {
+		frames, branch = openAndParseCache(cache_path)
+		fmt.Printf("Found cache...\n")
+	} else {
+		pcs, _ := coveredPcs(*targetArch, *f_vmlinuxPath, *f_rawformat)
+		if len(pcs) == 0 {
+			fmt.Printf("It seems vmlinux doesn't have any <__sanitizer_cov_trace_pc> functions. Try '-r' argument\n")
+			cache_exist = true
+		}
+		fmt.Printf("Scan OK\n")
+		frames, _, _ = symbolize(*f_vmlinuxPath, pcs, *targetArch, *targetOS)
+		fmt.Printf("Symbolize OK\n")
+	}
+
+	for _, frame := range frames {
+		if (strings.Contains(frame.Func, *f_funcname) && *f_strict == false) ||
+			(frame.Func == *f_funcname && *f_strict == true) {
+			if list[n].Found == false {
+				list[n].Funcname = frame.Func
+				list[n].Start = frame.PC
+				list[n].End = frame.PC
+				list[n].Line = frame.Line
+				list[n].File = frame.File
+				list[n].Found = true
+			} else {
+				list[n].End = frame.PC
+			}
+		} else if frame.Inline != true && frame.Func != *f_funcname && list[n].Found == true {
+			list = append(list, Range{Start: 0x0, End: 0x0, Found: false})
+			n++
+		}
+		if node, ok := branch[frame.PC]; ok {
+			for _, e := range trace {
+				if stripPrefix(frame.File) == e.condJump.File && frame.Line == e.condJump.Line {
+					followBy := node["followBy"]
+					jumpTo := node["jumpTo"]
+					r, _, _ := symbolize(*f_vmlinuxPath, []uint64{followBy}, *targetArch, *targetOS)
+					TFile := r[0].File
+					TLine := r[0].Line
+					r, _, _ = symbolize(*f_vmlinuxPath, []uint64{jumpTo + 5}, *targetArch, *targetOS) //A potential bug here is that the next inst is jmp xxx, need a special checker
+					FFile := r[0].File
+					FLine := r[0].Line
+					if stripPrefix(TFile) == e.correctPath.File && stripPrefix(FFile) == e.correctPath.File {
+						fmt.Printf("%d %d %d\n", TLine, FLine, e.correctPath.Line)
+						if TLine <= e.correctPath.Line && FLine > e.correctPath.Line {
+							//True
+							fmt.Printf("cond: %x correct: %x wrong: %x\n", frame.PC, followBy, jumpTo)
+						}
+						if FLine <= e.correctPath.Line {
+							//False
+							fmt.Printf("cond: %x correct: %x wrong: %x\n", frame.PC, jumpTo, followBy)
+						}
+					}
+				}
+			}
+
+		}
+	}
+
+	if cache_exist == false {
+		data1, _ := json.Marshal(frames)
+		data2, _ := json.Marshal(branch)
+		data1 = append(data1, []byte("\n")...)
+		data := append(data1, data2...)
+		createAndWriteCache(cache_path, data)
+	}
+	list = list[0 : len(list)-1 : len(list)]
+	for _, e := range list {
+		fmt.Printf("Function:%s\nStart:%x\nEnd:%x\nLocation:%s:%d\nFound:%t\n", e.Funcname, e.Start, e.End, e.File, e.Line, e.Found)
+	}
+}
+
+var prefix = ""
+
+func stripPrefix(path string) string {
+	parts := strings.Split(path, "/")
+	if prefix != "" {
+		r := strings.Split(path, prefix)
+		if len(r) == 2 {
+			return r[1]
+		}
+	}
+	for i := len(parts) - 1; i >= 0; i-- {
+		if parts[i] == "linux" {
+			prefix = strings.Join(parts[:i+1], "/") + "/"
+			return strings.Join(parts[i+1:], "/")
+		}
+	}
+	return path
+}
+
+func buildTrace(path2Trace string) bool {
+	var file string
+	var line int
+	traceFile, err := os.Open(path2Trace)
+	if err != nil {
+		fmt.Println(err)
+		return false
+	}
+	r := bufio.NewReader(traceFile)
+	for {
+		ln, _, err := r.ReadLine()
+		if ln == nil {
+			return true
+		}
+		if err != nil {
+			fmt.Println(err)
+			return false
+		}
+		space := bytes.IndexByte(ln, ' ')
+		file, line = parseTrace(ln[:space])
+		condJump := TraceInfo{File: file, Line: line}
+		file, line = parseTrace(ln[space+1:])
+		correctPath := TraceInfo{File: file, Line: line}
+		trace = append(trace, Trace{condJump: condJump, correctPath: correctPath})
+	}
+}
+
+func parseTrace(line []byte) (string, int) {
+	colon := bytes.IndexByte(line, ':')
+	val, _ := strconv.Atoi(string(line[colon+1:]))
+	return string(line[:colon]), val
+}
+
+func getFrameByPc(base int, frames []symbolizer.Frame, pc uint64) (string, int) {
+	for i := base; i < len(frames); i++ {
+		if frames[i].PC == pc {
+			return frames[i].File, frames[i].Line
+		}
+	}
+	return "", -1
+}
+
+func coveredPcs(arch, bin string, rawformat bool) ([]uint64, error) {
+	cmd := osutil.Command("objdump", "-d", "--no-show-raw-insn", bin)
+	stdout, err := cmd.StdoutPipe()
+	if err != nil {
+		return nil, err
+	}
+	defer stdout.Close()
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+	defer cmd.Wait()
+	var pcs []uint64
+	s := bufio.NewScanner(stdout)
+
+	iBase := 18
+	var jumpTo, addr uint64
+	jumpTo = 0
+	addr = 0
+	for s.Scan() {
+		ln := s.Bytes()
+		colon := bytes.IndexByte(ln, ':')
+		if colon == -1 {
+			continue
+		}
+		pc, err := strconv.ParseUint(string(ln[:colon]), 16, 64)
+		if err != nil {
+			continue
+		}
+		//find a conditional jump
+
+		if jumpTo != 0 && addr != 0 {
+			branch[addr] = map[string]uint64{"jumpTo": jumpTo, "followBy": pc}
+			jumpTo = 0
+			addr = 0
+		}
+		if ln[iBase] == 'j' {
+			if pos := bytes.Index(ln, []byte("jmp")); pos != -1 {
+				continue
+			}
+			pos := bytes.Index(ln[iBase:], []byte("f"))
+			if (pos != -1) && (len(ln[iBase:]) > pos+16) {
+				jumpTo, err = strconv.ParseUint(string(ln[pos+iBase:pos+iBase+16]), 16, 64)
+				if err != nil {
+					continue
+				}
+				addr = pc
+			}
+			pcs = append(pcs, pc)
+		}
+	}
+	if err := s.Err(); err != nil {
+		return nil, err
+	}
+	return pcs, nil
+}
+
+func symbolize(vmlinux string, pcs []uint64, arch, os string) ([]symbolizer.Frame, string, error) {
+	symb := symbolizer.NewSymbolizer()
+	defer symb.Close()
+
+	frames, err := symb.SymbolizeArray(vmlinux, pcs)
+	if err != nil {
+		return nil, "", err
+	}
+
+	return frames, "", nil
+}
+
+func openAndParseCache(path string) ([]symbolizer.Frame, map[uint64]map[string]uint64) {
+	var frame []symbolizer.Frame
+	branch := make(map[uint64]map[string]uint64)
+
+	jsonFile, err := os.Open(path)
+	if err != nil {
+		fmt.Println(err)
+		return nil, nil
+	}
+	data, _ := ioutil.ReadAll(jsonFile)
+	newln := bytes.IndexByte(data, '\n')
+
+	json.Unmarshal([]byte(data[:newln]), &frame)
+	json.Unmarshal([]byte(data[newln+1:]), &branch)
+	jsonFile.Close()
+	return frame, branch
+}
+
+func createAndWriteCache(path string, data []byte) {
+	jsonFile, err := os.Create(path)
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	jsonFile.Write(data)
+	jsonFile.Close()
+}
+
+func isCacheExist(_dCache, _vmlinuxPath string) (bool, string) {
+	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
+	if err != nil {
+		log.Fatal(err)
+	}
+	cache_base := dir + "/fun2addr_cache"
+	if _, err := os.Stat(cache_base); os.IsNotExist(err) {
+		var mode os.FileMode
+		mode = 0755
+		os.Mkdir(cache_base, mode)
+	}
+	h := md5.New()
+	if _dCache != "" {
+		h.Write([]byte(_dCache))
+	} else {
+		h.Write([]byte(_vmlinuxPath))
+	}
+	hash := hex.EncodeToString(h.Sum(nil))
+	cache_path := cache_base + "/" + string(hash[:len(hash)])
+	if _, err := os.Stat(cache_path); os.IsNotExist(err) {
+		return false, cache_path
+	}
+	return true, cache_path
+}
diff --git a/tools/syz-crush/crush.go b/tools/syz-crush/crush.go
index 33b9ccef..6796b061 100644
--- a/tools/syz-crush/crush.go
+++ b/tools/syz-crush/crush.go
@@ -113,7 +113,7 @@ func runInstance(cfg *mgrconfig.Config, reporter report.Reporter, vmPool *vm.Poo
 	}
 
 	log.Logf(0, "vm-%v: crushing...", index)
-	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitTimeout)
+	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitTimeout, time.Now(), -1)
 	if rep == nil {
 		// This is the only "OK" outcome.
 		log.Logf(0, "vm-%v: running long enough, restarting", index)
diff --git a/tools/syz-logparser/syz-logparser.go b/tools/syz-logparser/syz-logparser.go
new file mode 100644
index 00000000..b613297e
--- /dev/null
+++ b/tools/syz-logparser/syz-logparser.go
@@ -0,0 +1,89 @@
+package main
+
+import (
+	"bufio"
+	"flag"
+	"fmt"
+	"os"
+
+	"github.com/google/syzkaller/pkg/mgrconfig"
+	"github.com/google/syzkaller/pkg/report"
+)
+
+func main() {
+	var (
+		flagInput  = flag.String("i", "", "input: path of a raw bug report")
+		flagOutput = flag.String("o", "", "output: path of a decent bug report")
+		flagUsage  = flag.Bool("u", false, "Get the usage")
+		flagConfig = flag.String("cfg", "", "Path of syzkaller config")
+	)
+	flag.Parse()
+	if *flagInput == "" || *flagConfig == "" || *flagOutput == "" || *flagUsage {
+		fmt.Printf("Usage:  syz-logparser -cfg path2cfg -i path2log -o path2write\n")
+		return
+	}
+
+	cfg, err := mgrconfig.LoadFile(*flagConfig)
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	output := loadLog(*flagInput)
+	if len(output) == 0 {
+		fmt.Printf("No bug report found in the given path\n")
+		return
+	}
+	rep, err := report.NewReporter(cfg)
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	report := rep.Parse(output)
+	if err := rep.Symbolize(report); err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	if !writeLog(*flagOutput, report.Report) {
+		fmt.Println("Fail to write to the given path")
+		return
+	}
+}
+
+func loadLog(path string) []byte {
+	var output []byte
+
+	logFile, err := os.Open(path)
+	if err != nil {
+		fmt.Println(err)
+		return output
+	}
+	r := bufio.NewReader(logFile)
+	for {
+		ln, _, err := r.ReadLine()
+		if ln == nil {
+			break
+		}
+		if err != nil {
+			fmt.Println(err)
+			break
+		}
+		ln = append(ln, '\n')
+		output = append(output, ln...)
+	}
+	logFile.Close()
+	return output
+}
+
+func writeLog(path string, output []byte) bool {
+	logFile, err := os.Create(path)
+	if err != nil {
+		fmt.Println(err)
+		return false
+	}
+	w := bufio.NewWriter(logFile)
+	w.Write(output)
+	w.Flush()
+	logFile.Close()
+	return true
+}
diff --git a/tools/syz-runtest/runtest.go b/tools/syz-runtest/runtest.go
index 76c120cd..d7d5f1fa 100644
--- a/tools/syz-runtest/runtest.go
+++ b/tools/syz-runtest/runtest.go
@@ -184,12 +184,12 @@ func (mgr *Manager) boot(name string, index int) (*report.Report, error) {
 	}
 	cmd := instance.FuzzerCmd(fuzzerBin, executorCmd, name,
 		mgr.cfg.TargetOS, mgr.cfg.TargetArch, fwdAddr, mgr.cfg.Sandbox, mgr.cfg.Procs, 0,
-		mgr.cfg.Cover, mgr.debug, false, true)
+		mgr.cfg.Cover, mgr.debug, false, true, false)
 	outc, errc, err := inst.Run(time.Hour, mgr.vmStop, cmd)
 	if err != nil {
 		return nil, fmt.Errorf("failed to run fuzzer: %v", err)
 	}
-	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitNormal)
+	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitNormal, time.Now(), -1)
 	return rep, nil
 }
 
diff --git a/vm/qemu/qemu.go b/vm/qemu/qemu.go
index bddace8f..64f52e90 100644
--- a/vm/qemu/qemu.go
+++ b/vm/qemu/qemu.go
@@ -186,7 +186,7 @@ var linuxCmdline = []string{
 	"earlyprintk=serial",
 	"oops=panic",
 	"nmi_watchdog=panic",
-	"panic_on_warn=1",
+	//"panic_on_warn=1",
 	"panic=1",
 	"ftrace_dump_on_oops=orig_cpu",
 	"rodata=n",
@@ -383,6 +383,7 @@ func (inst *instance) boot() error {
 			)
 		}
 		cmdline = append(cmdline, inst.cfg.Cmdline)
+		cmdline = append(cmdline, "kasan_multi_shot=1")
 		args = append(args,
 			"-kernel", inst.cfg.Kernel,
 			"-append", strings.Join(cmdline, " "),
diff --git a/vm/vm.go b/vm/vm.go
index 1b6e7eb2..e35d76df 100644
--- a/vm/vm.go
+++ b/vm/vm.go
@@ -15,6 +15,7 @@ import (
 	"path/filepath"
 	"time"
 
+	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/mgrconfig"
 	"github.com/google/syzkaller/pkg/osutil"
 	"github.com/google/syzkaller/pkg/report"
@@ -162,7 +163,7 @@ const (
 // Exit says which exit modes should be considered as errors/OK.
 // Returns a non-symbolized crash report, or nil if no error happens.
 func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
-	reporter report.Reporter, exit ExitCondition) (rep *report.Report) {
+	reporter report.Reporter, exit ExitCondition, managerStart time.Time, timeLimit int) (rep *report.Report) {
 	mon := &monitor{
 		inst:     inst,
 		outc:     outc,
@@ -233,6 +234,10 @@ func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
 			if mon.matchPos < 0 {
 				mon.matchPos = 0
 			}
+			if timeLimit >= 0 && time.Since(managerStart) >= time.Duration(timeLimit)*time.Hour {
+				log.Logf(0, "running for %d hours, exit now.", timeLimit)
+				return nil
+			}
 		case <-ticker.C:
 			// Detect both "not output whatsoever" and "kernel episodically prints
 			// something to console, but fuzzer is not actually executing programs".
@@ -257,7 +262,7 @@ func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
 				mon.waitForOutput()
 			}
 			rep := &report.Report{
-				Title:      noOutputCrash,
+				Title:      NoOutputCrash,
 				Output:     mon.output,
 				Suppressed: report.IsSuppressed(mon.reporter, mon.output),
 			}
@@ -353,7 +358,7 @@ const (
 	maxErrorLength = 256
 
 	lostConnectionCrash  = "lost connection to test machine"
-	noOutputCrash        = "no output from test machine"
+	NoOutputCrash        = "no output from test machine"
 	timeoutCrash         = "timed out"
 	executingProgramStr1 = "executing program"  // syz-fuzzer output
 	executingProgramStr2 = "executed programs:" // syz-execprog output
diff --git a/vm/vm_test.go b/vm/vm_test.go
index 73c3198a..0cca48fa 100644
--- a/vm/vm_test.go
+++ b/vm/vm_test.go
@@ -218,7 +218,7 @@ var tests = []*Test{
 		Body: func(outc chan []byte, errc chan error) {
 		},
 		Report: &report.Report{
-			Title: noOutputCrash,
+			Title: NoOutputCrash,
 		},
 	},
 	{
@@ -230,7 +230,7 @@ var tests = []*Test{
 			}
 		},
 		Report: &report.Report{
-			Title: noOutputCrash,
+			Title: NoOutputCrash,
 		},
 	},
 	{
@@ -345,7 +345,7 @@ func testMonitorExecution(t *testing.T, test *Test) {
 		test.Body(testInst.outc, testInst.errc)
 		done <- true
 	}()
-	rep := inst.MonitorExecution(outc, errc, reporter, test.Exit)
+	rep := inst.MonitorExecution(outc, errc, reporter, test.Exit, time.Now(), -1)
 	<-done
 	if test.Report != nil && rep == nil {
 		t.Fatalf("got no report")
